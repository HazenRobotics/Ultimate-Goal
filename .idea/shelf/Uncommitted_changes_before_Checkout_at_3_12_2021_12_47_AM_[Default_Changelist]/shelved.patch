Index: FtcRobotController/src/main/res/layout/activity_ftc_controller.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><!--\r\nCopyright (c) 2014, 2015 Qualcomm Technologies Inc\r\n\r\nAll rights reserved.\r\n\r\nRedistribution and use in source and binary forms, with or without modification,\r\nare permitted (subject to the limitations in the disclaimer below) provided that\r\nthe following conditions are met:\r\n\r\nRedistributions of source code must retain the above copyright notice, this list\r\nof conditions and the following disclaimer.\r\n\r\nRedistributions in binary form must reproduce the above copyright notice, this\r\nlist of conditions and the following disclaimer in the documentation and/or\r\nother materials provided with the distribution.\r\n\r\nNeither the name of Qualcomm Technologies Inc nor the names of its contributors\r\nmay be used to endorse or promote products derived from this software without\r\nspecific prior written permission.\r\n\r\nNO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\r\nLICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\r\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\r\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n-->\r\n\r\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n              xmlns:tools=\"http://schemas.android.com/tools\"\r\n              android:layout_width=\"match_parent\"\r\n              android:layout_height=\"match_parent\"\r\n              xmlns:style=\"http://schemas.android.com/apk/res-auto\"\r\n              tools:context=\"org.firstinspires.ftc.robotcontroller.internal.FtcRobotControllerActivity\"\r\n              android:focusable=\"true\"\r\n              android:id=\"@+id/entire_screen\"\r\n              android:orientation=\"vertical\">\r\n\r\n  <!-- black bar on top -->\r\n  <RelativeLayout\r\n    android:id=\"@+id/top_bar\"\r\n    android:layout_width=\"fill_parent\"\r\n    android:layout_height=\"80dp\"\r\n    android:background=\"@color/background_black\">\r\n\r\n    <ImageView\r\n      android:id=\"@+id/robotIcon\"\r\n      android:src=\"@drawable/icon_robotcontroller\"\r\n      android:layout_width=\"wrap_content\"\r\n      android:layout_height=\"fill_parent\"\r\n      android:adjustViewBounds=\"true\"\r\n      android:layout_margin=\"1dp\"/>\r\n\r\n    <TextView\r\n      android:id=\"@+id/textDeviceName\"\r\n      android:layout_toEndOf=\"@id/robotIcon\"\r\n      android:layout_width=\"wrap_content\"\r\n      android:layout_height=\"wrap_content\"\r\n      android:textColor=\"?attr/textWhite\"\r\n      android:textAppearance=\"?android:attr/textAppearanceMedium\"\r\n      android:padding=\"8dp\"\r\n      android:textStyle=\"bold\"/>\r\n\r\n    <ImageButton\r\n      android:id=\"@+id/menu_buttons\"\r\n      android:scaleType=\"fitXY\"\r\n      android:layout_width=\"wrap_content\"\r\n      android:layout_height=\"wrap_content\"\r\n      android:src=\"@drawable/icon_menu\"\r\n      android:background=\"@android:color/transparent\"\r\n      android:padding=\"15dp\"\r\n      android:adjustViewBounds=\"true\"\r\n      android:layout_alignParentEnd=\"true\"\r\n      android:layout_centerInParent=\"true\"\r\n      android:layout_centerHorizontal=\"true\"\r\n      android:layout_margin=\"10dp\"/>\r\n\r\n  </RelativeLayout>\r\n  <!-- end of black bar -->\r\n\r\n  <include layout=\"@layout/header\"\r\n           android:id=\"@+id/included_header\"/>\r\n\r\n  <RelativeLayout\r\n    android:background=\"@color/background_very_light_grey\"\r\n    android:id=\"@+id/RelativeLayout\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    android:keepScreenOn=\"true\"\r\n    android:paddingBottom=\"@dimen/activity_vertical_margin\"\r\n    android:paddingLeft=\"@dimen/activity_horizontal_margin\"\r\n    android:paddingRight=\"@dimen/activity_horizontal_margin\"\r\n    android:paddingTop=\"@dimen/activity_vertical_margin\" >\r\n\r\n    <TextView\r\n      android:id=\"@+id/textNetworkConnectionStatus\"\r\n      android:layout_width=\"match_parent\"\r\n      android:layout_height=\"wrap_content\"\r\n      android:visibility=\"invisible\"\r\n      android:text=\"\" />\r\n\r\n    <TextView\r\n      android:id=\"@+id/textRobotStatus\"\r\n      android:layout_width=\"match_parent\"\r\n      android:layout_height=\"wrap_content\"\r\n      android:layout_below=\"@+id/textNetworkConnectionStatus\"\r\n      android:visibility=\"invisible\"\r\n      android:text=\"\" />\r\n\r\n    <TextView\r\n      android:id=\"@+id/textOpMode\"\r\n      android:layout_width=\"match_parent\"\r\n      android:layout_height=\"wrap_content\"\r\n      android:layout_below=\"@+id/textRobotStatus\"\r\n      android:visibility=\"invisible\"\r\n      android:text=\"\" />\r\n\r\n    <FrameLayout\r\n      android:layout_width=\"match_parent\"\r\n      android:layout_height=\"wrap_content\"\r\n      android:layout_below=\"@+id/textOpMode\"\r\n      android:layout_above=\"@+id/textGamepad1\">\r\n\r\n      <LinearLayout\r\n          android:id=\"@+id/monitorContainer\"\r\n          android:layout_width=\"match_parent\"\r\n          android:layout_height=\"match_parent\"\r\n          android:orientation=\"vertical\">\r\n\r\n        <LinearLayout\r\n            android:id=\"@+id/cameraMonitorViewId\"\r\n            android:visibility=\"gone\"\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"0dp\"\r\n            android:layout_weight=\"1\"\r\n            android:orientation=\"vertical\"\r\n            />\r\n        <FrameLayout\r\n            android:id=\"@+id/tfodMonitorViewId\"\r\n            android:visibility=\"gone\"\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"0dp\"\r\n            android:layout_weight=\"1\"\r\n            />\r\n\r\n        </LinearLayout>\r\n\r\n      <!-- When visible, the error message will overlay and thus partially\r\n           obscure part of the camera monitor. We make this trade off so as to\r\n           allow for a bigger camera monitor view in the common case when the\r\n           error is not in fact present\r\n        -->\r\n        <TextView style=\"@style/FtcTextViewStyleBold\"\r\n            android:id=\"@+id/textErrorMessage\"\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:text=\"\"\r\n            android:visibility=\"invisible\"\r\n            android:textColor=\"?attr/textMediumDark\" />\r\n\r\n    </FrameLayout>\r\n\r\n    <TextView\r\n      android:id=\"@+id/textGamepad1\"\r\n      android:layout_width=\"match_parent\"\r\n      android:layout_height=\"wrap_content\"\r\n      android:layout_above=\"@+id/textGamepad2\"\r\n      android:visibility=\"invisible\"\r\n      android:text=\"\" />\r\n\r\n    <TextView\r\n      android:id=\"@+id/textGamepad2\"\r\n      android:layout_width=\"match_parent\"\r\n      android:layout_height=\"wrap_content\"\r\n      android:layout_alignParentBottom=\"true\"\r\n      android:visibility=\"invisible\"\r\n      android:text=\"\" />\r\n\r\n  </RelativeLayout>\r\n\r\n  <WebView\r\n    android:id=\"@+id/webViewBlocksRuntime\"\r\n    android:layout_width=\"1dp\"\r\n    android:layout_height=\"1dp\" />\r\n\r\n</LinearLayout>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- FtcRobotController/src/main/res/layout/activity_ftc_controller.xml	(revision 53e48190b46a1720c0dd53bbcd6542a1d8ccecc0)
+++ FtcRobotController/src/main/res/layout/activity_ftc_controller.xml	(date 1615538687251)
@@ -83,8 +83,10 @@
   </RelativeLayout>
   <!-- end of black bar -->
 
-  <include layout="@layout/header"
-           android:id="@+id/included_header"/>
+  <include
+      android:id="@+id/included_header"
+      layout="@layout/header"
+      android:layout_height="49dp" />
 
   <RelativeLayout
     android:background="@color/background_very_light_grey"
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/utils/Tracking.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.utils;\r\n\r\nimport com.qualcomm.hardware.bosch.BNO055IMU;\r\nimport com.qualcomm.hardware.bosch.JustLoggingAccelerationIntegrator;\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\n\r\nimport org.firstinspires.ftc.robotcore.external.navigation.*;\r\nimport org.firstinspires.ftc.teamcode.drives.*;\r\nimport org.firstinspires.ftc.teamcode.*;\r\n\r\nimport java.util.Locale;\r\n\r\npublic class Tracking {\r\n\r\n    BNO055IMU gyro;\r\n    MecanumDrive mecanumDrive;\r\n    Orientation angles;\r\n    Acceleration gravity;\r\n\r\n    public Tracking( MecanumDrive mDrv, HardwareMap hw ) {\r\n\r\n        mecanumDrive = mDrv;\r\n\r\n        initGyro(hw);\r\n\r\n    }\r\n\r\n    /**\r\n     * returns the Longitudinal (forward/backward) distance on the encoders from where it started\r\n     * @return mecanumDrive.getBackLeftPosition();\r\n     */\r\n    public int getLongitudinalPosition() {\r\n        return mecanumDrive.getBackLeftPosition();\r\n    }\r\n\r\n    /**\r\n     * returns the Lateral (left/right) distance on the encoders from where it started\r\n     * @return mecanumDrive.getBackLeftPosition();\r\n     */\r\n    public int getLateralPosition() {\r\n        return mecanumDrive.getFrontLeftPosition();\r\n    }\r\n\r\n    public void initGyro( HardwareMap hw ) {\r\n        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();\r\n        parameters.angleUnit           = BNO055IMU.AngleUnit.DEGREES;\r\n        parameters.accelUnit           = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;\r\n        parameters.calibrationDataFile = \"BNO055IMUCalibration.json\"; // see the calibration sample opmode\r\n        parameters.loggingEnabled      = true;\r\n        parameters.loggingTag          = \"IMU\";\r\n        parameters.accelerationIntegrationAlgorithm = new JustLoggingAccelerationIntegrator();\r\n\r\n        gyro = hw.get( BNO055IMU.class, \"imu\" );\r\n        gyro.initialize(parameters);\r\n\r\n        angles = gyro.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n\r\n    }\r\n\r\n    public double getGyroXVelocity() {\r\n        return gyro.getVelocity().xVeloc;\r\n    }\r\n\r\n    public double getGyroYVelocity() {\r\n        return gyro.getVelocity().yVeloc;\r\n    }\r\n\r\n    public double getGyroZVelocity() {\r\n        return gyro.getVelocity().zVeloc;\r\n    }\r\n\r\n    public float get360GyroHeading() {\r\n        return getGyroHeading();\r\n    }\r\n\r\n    public float getGyroHeading() {\r\n        angles = gyro.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n        return angles.firstAngle;\r\n        //return formatAngle(angles.angleUnit, angles.firstAngle);\r\n    }\r\n\r\n    public float getGyroRoll() {\r\n        angles = gyro.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n        return angles.secondAngle;\r\n        //return formatAngle(angles.angleUnit, angles.secondAngle);\r\n    }\r\n\r\n    public float getGyroPitch() {\r\n        angles = gyro.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n        return angles.thirdAngle;\r\n    }\r\n\r\n    public float getNewGyroHeading()\r\n    {\r\n        return (-getGyroHeading() + 360) % 360;\r\n    }\r\n    /**\r\n     * will sleep the robot for [millis] milliseconds\r\n     * @param millis\r\n     */\r\n    public void sleep( long millis ) {\r\n        long startTime = System.currentTimeMillis();\r\n        while( System.currentTimeMillis() < startTime + millis );\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/utils/Tracking.java	(revision 53e48190b46a1720c0dd53bbcd6542a1d8ccecc0)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/utils/Tracking.java	(date 1615538846508)
@@ -22,7 +22,6 @@
         mecanumDrive = mDrv;
 
         initGyro(hw);
-
     }
 
     /**
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/robots/RobotWood.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.robots;\r\n\r\nimport android.util.Log;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\n\r\nimport org.firstinspires.ftc.teamcode.drives.MecanumDrive;\r\nimport org.firstinspires.ftc.teamcode.mechanisms.GoalLift;\r\nimport org.firstinspires.ftc.teamcode.utils.*;\r\n\r\npublic class RobotWood extends Robot {\r\n\r\n    public MecanumDrive mecanumDrive;\r\n\r\n    public GoalLift goalLift;\r\n\r\n    public Tracking tracker;\r\n\r\n    public TensorFlowUtil tensorFlowUtil;\r\n\r\n    //\r\n    public static double MIN_POWER = 0.1;\r\n\r\n    public RobotWood(HardwareMap hw, OpMode op){\r\n        super(hw, op);\r\n\r\n        super.driveTrain = new MecanumDrive(hw);\r\n        mecanumDrive = (MecanumDrive) driveTrain;\r\n        tracker = new Tracking(mecanumDrive, hw);\r\n        goalLift = new GoalLift(hw);\r\n        tensorFlowUtil = new TensorFlowUtil(hw, op);\r\n\r\n    }\r\n\r\n    public void dropOffGoal() { Log.e(\"|-|-|-| \", \"dropOffGoal();\");\r\n\r\n        TensorFlowUtil.Stack stackPos = tensorFlowUtil.getStack();\r\n\r\n        switch( stackPos ) {\r\n            case NONE:\r\n                driveToZoneA();\r\n                break;\r\n            case SINGLE:\r\n                driveToZoneB();\r\n                break;\r\n            case QUAD:\r\n                driveToZoneC();\r\n                break;\r\n        }\r\n\r\n    }\r\n    public void driveToZoneA() { // 0 rings :: target zone A\r\n\r\n        Log.e(\"|-|-|-| \", \"driveToZonA();\");\r\n\r\n        telemetry.addLine( \"driveToZoneA()\" );\r\n        telemetry.update();\r\n\r\n        driveDistance(12, -0.75, true);\r\n\r\n        // drive backwards a bit\r\n        // strafe right 4 feet\r\n        // drop goal\r\n\r\n    }\r\n\r\n    public void driveToZoneB() { // 1 ring :: target zone B\r\n\r\n        Log.e(\"|-|-|-| \", \"driveToZoneB()\");\r\n\r\n        telemetry.addLine( \"driveToZoneB()\" );\r\n        telemetry.update();\r\n\r\n        strafeDistance(12, -0.75, true);\r\n\r\n        // strafe right 2 feet\r\n        // drive forward\r\n        // drop goal\r\n\r\n    }\r\n\r\n    public void driveToZoneC() { // 4 rings :: target zone C\r\n\r\n        Log.e(\"|-|-|-| \", \"driveToZoneC();\");\r\n\r\n        telemetry.addLine( \"driveToZoneC()\" );\r\n        telemetry.update();\r\n\r\n        driveDistance(12, 0.75, true);\r\n\r\n        // strafe right 4 feet\r\n        // drive forward 4 feet\r\n        // drop goal\r\n\r\n    }\r\n\r\n    public void drive(double drivePower, double strafePower, double rotatePower) {\r\n        mecanumDrive.drive(drivePower, strafePower, rotatePower);\r\n    }\r\n\r\n    public void driveDistance( double distance, double power, boolean setPowerZero ) {\r\n\r\n        mecanumDrive.drive( power, 0, 0 );\r\n\r\n        int ticksToTravel = mecanumDrive.convertDistTicks(distance);\r\n        int initialXPos = tracker.getLateralPosition();\r\n        int initialYPos = tracker.getLongitudinalPosition();\r\n        double percent = 0.5;\r\n\r\n        mecanumDrive.drive( power, 0, 0 );\r\n        while( tracker.getLateralPosition() - initialXPos < ticksToTravel && opModeIsActive() ) {\r\n\r\n            /*\r\n            double m = (power-(Math.signum(power)*MIN_POWER))/(-distance*(1-distance));\r\n            double x = mecanumDrive.convertDistTicks(tracker.getLateralPosition() - ticksToTravel);\r\n            double b = (Math.signum(power)*MIN_POWER)-m*distance;\r\n\r\n            if( tracker.getLateralPosition() - initialXPos > ticksToTravel*percent )\r\n                power = m*x + b;\r\n\r\n             */\r\n\r\n            mecanumDrive.drive( power, 0, 0 );\r\n        }\r\n\r\n        //sets all power to zero afterwords\r\n        if(setPowerZero)\r\n            mecanumDrive.drive( 0, 0, 0 );\r\n    }\r\n\r\n    public void strafeDistance( double distance, double power, boolean setPowerZero ) {\r\n\r\n        mecanumDrive.drive( 0, power, 0 );\r\n\r\n        int ticksToTravel = mecanumDrive.convertDistTicks(distance);\r\n        int initialXPos = tracker.getLateralPosition();\r\n        int initialYPos = tracker.getLongitudinalPosition();\r\n        double percent = 0.5;\r\n\r\n        mecanumDrive.drive( 0, power, 0 );\r\n        while( tracker.getLongitudinalPosition() - initialYPos < ticksToTravel && opModeIsActive()) {\r\n\r\n            double m = (power-(Math.signum(power)*MIN_POWER))/(-distance*(1-distance));\r\n            double x = mecanumDrive.convertDistTicks(tracker.getLateralPosition() - ticksToTravel);\r\n            double b = (Math.signum(power)*MIN_POWER)-m*distance;\r\n\r\n            if( tracker.getLongitudinalPosition() - initialXPos > ticksToTravel*percent )\r\n                power = m*x + b;\r\n\r\n            mecanumDrive.drive( 0, power, 0 );\r\n        }\r\n\r\n        //sets all power to zero afterwords\r\n        if(setPowerZero)\r\n            mecanumDrive.drive( 0, 0, 0 );\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param degrees forward is zero, turning right is positive, limit: 359 degrees\r\n     * @param power positive will turn right, negative turns left\r\n     * @param setPowerZero if true, will set the power to zero once finished\r\n     */\r\n    public void rotateDegrees( double degrees, double power, boolean setPowerZero ) {\r\n\r\n        mecanumDrive.drive( 0, 0, power );\r\n\r\n        double initialDegrees = tracker.getGyroHeading();\r\n\r\n        if( degrees > 0 )\r\n            while( tracker.getGyroHeading() - initialDegrees < degrees && opModeIsActive())\r\n                mecanumDrive.drive( 0, 0, power );\r\n        else if( degrees < 0 )\r\n            while( tracker.getGyroHeading() - initialDegrees > degrees && opModeIsActive())\r\n                mecanumDrive.drive( 0, 0, power );\r\n\r\n        //sets all power to zero afterwords\r\n        if(setPowerZero) {\r\n            mecanumDrive.drive( 0, 0, 0 );\r\n        }\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param degrees forward is zero, turning right is positive, limit: 359 degrees\r\n     * @param power positive will turn right, negative turns left\r\n     */\r\n    public void rotateDegrees( double degrees, double power ) throws InterruptedException {\r\n\r\n        //mecanumDrive.drive( 0, 0, power );\r\n\r\n        double initialDegrees = tracker.get360GyroHeading();\r\n        double percent = 0.5;\r\n        double variable = 5*power;\r\n\r\n        if (power > 0) {\r\n            mecanumDrive.drive( 0, 0, power );\r\n            sleep( 250 );\r\n            while( opModeIsActive() && tracker.get360GyroHeading() - initialDegrees < degrees - variable )\r\n            {\r\n                telemetry.addData(\"While:\", tracker.get360GyroHeading() - initialDegrees < degrees)\r\n                        .addData(\"While:\", tracker.get360GyroHeading() - initialDegrees > degrees)\r\n                        .addData(\"Heading\", tracker.get360GyroHeading());\r\n                telemetry.update();\r\n\r\n                double m = (power-(Math.signum(power)*MIN_POWER))/(-degrees*(1-percent));\r\n                double x = tracker.get360GyroHeading() - initialDegrees;\r\n                double b = (Math.signum(power)*MIN_POWER)-m*degrees;\r\n\r\n                if( tracker.get360GyroHeading() - initialDegrees > degrees*percent )\r\n                    power = m*x + b;\r\n                mecanumDrive.drive( 0, 0, power );\r\n            }\r\n            mecanumDrive.drive( 0, 0, 0 );\r\n        }\r\n        else if ( power != 0 )\r\n        {\r\n            mecanumDrive.drive( 0, 0, power );\r\n            while( opModeIsActive() && tracker.get360GyroHeading() - initialDegrees > degrees + variable )\r\n            {\r\n                telemetry.addData(\"While:\", tracker.get360GyroHeading() - initialDegrees < degrees)\r\n                        .addData(\"While:\", tracker.get360GyroHeading() - initialDegrees > degrees)\r\n                        .addData(\"Heading\", tracker.get360GyroHeading());\r\n                telemetry.update();\r\n\r\n                double m = (power-(Math.signum(power)*MIN_POWER))/(-degrees*(1-percent));\r\n                double x = tracker.get360GyroHeading() - initialDegrees;\r\n                double b = (Math.signum(power)*MIN_POWER)-m*degrees;\r\n\r\n                if( tracker.get360GyroHeading() - initialDegrees > degrees*percent )\r\n                    power = m*x + b;\r\n                mecanumDrive.drive( 0, 0, power );\r\n                mecanumDrive.drive( 0, 0, power );\r\n            }\r\n            mecanumDrive.drive( 0, 0, 0 );\r\n        }\r\n\r\n        /*\r\n        while( opModeIsActive())\r\n        {\r\n            telemetry.addData(\"getGyroHeading\", tracker.getGyroHeading())\r\n                    .addData(\"getNewGyroHeading\", tracker.getNewGyroHeading());\r\n            telemetry.update();\r\n        }*/\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * @param drivePower - sets power to drive - negative power is backwards\r\n     * @param strafePower - sets power to strafe - negative power is left\r\n     * @param time - amount of time to run the motors in MILLISECONDS\r\n     */\r\n    public void omniTime(double drivePower, double strafePower, long time, boolean setPowerZero)\r\n    {\r\n        //gyro.resetZAxisIntegrator();\r\n        //set power to 'drive' motors\r\n\r\n        mecanumDrive.drive(drivePower, strafePower, 0);\r\n\r\n        //wait for certain amount of time while motors are running\r\n        //robotMecanum.wait(time);\r\n        long setTime = System.currentTimeMillis();\r\n        previousTime = opMode.getRuntime();\r\n\r\n        while(System.currentTimeMillis() - setTime < (time) && opModeIsActive())\r\n        {\r\n            mecanumDrive.drive(drivePower, strafePower, /*gyroPID(180, opMode.getRuntime() - previousTime)*/0);\r\n        }\r\n\r\n        //sets all power to zero afterwords\r\n        if(setPowerZero) {\r\n            mecanumDrive.drive( 0, 0, 0 );\r\n        }\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/robots/RobotWood.java	(revision 53e48190b46a1720c0dd53bbcd6542a1d8ccecc0)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/robots/RobotWood.java	(date 1615538846524)
@@ -19,7 +19,6 @@
 
     public TensorFlowUtil tensorFlowUtil;
 
-    //
     public static double MIN_POWER = 0.1;
 
     public RobotWood(HardwareMap hw, OpMode op){
